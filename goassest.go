package main

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

var outFileName = "assest.go"

var tpl = template.Must(template.New("static").Parse(`
/**
* generated by goassest
* https://github.com/hidu/goassest/
*/
package {{.package}}

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"io/ioutil"
	"net/http"
	"path/filepath"
	"fmt"
	"time"
	"mime"
	"path"
	"os"
)

type StaticFile struct{
	Name string
	Mtime int64
	Content string
}

type StaticFiles map[string]*StaticFile

//for debug
var DebugAssestDir string=""

func (statics StaticFiles)GetStaticFile(name string) (*StaticFile,error){
	if(DebugAssestDir!=""){
		return getStaticFile(DebugAssestDir,name)
	}
	if sf,has:=statics[path.Clean(name)];has{
		return sf,nil
	}
	return nil,fmt.Errorf("not exists")
}

func getStaticFile(baseDir string,name string)(*StaticFile,error){
	fullPath:=baseDir+string(filepath.Separator)+name
	f,err:=os.Open(fullPath)
	if(err!=nil){
		return nil,err
	}
	defer f.Close()
	info,err:=f.Stat()
	if(err!=nil){
		return nil,err
	}
	if(info.Mode().IsRegular()){
		content,err:=ioutil.ReadAll(f)
		if(err!=nil){
			return nil,err
		}
		return &StaticFile{
			Content:string(content),
			Name:name,
			Mtime:info.ModTime().Unix(),
		},nil
	}
	return nil,fmt.Errorf("not file")
}

/**
*res.DebugAssestDir="../";//for debug read it direct
*http.Handle("/res/",res.Files.HttpHandler("/res/"))
*/
func (statics *StaticFiles)HttpHandler(pdir string)http.Handler{
	return &fileServer{sf:statics,pdir:pdir}
}


func decode(data string)string{
  b,_:=base64.StdEncoding.DecodeString(data)
  gr, _:= gzip.NewReader(bytes.NewBuffer(b))
  bs, _ := ioutil.ReadAll(gr)
  return string(bs)
}

func base64decode(data string)string{
   b,_:=base64.StdEncoding.DecodeString(data)
   return string(b)
}

type fileServer struct{
	sf *StaticFiles
	pdir string
}


func (f *fileServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	rname,_:=filepath.Rel(f.pdir,r.URL.Path)
	static,err:=f.sf.GetStaticFile(rname)
	if(err!=nil){
		http.NotFound(w,r)
		return
	}
	modtime:=time.Unix(static.Mtime,0)
	modifiedSince:=r.Header.Get("If-Modified-Since")
	if modifiedSince!=""{
		t, err := time.Parse(http.TimeFormat, modifiedSince)
		if err == nil && modtime.Before(t.Add(1*time.Second)) {
			h := w.Header()
			delete(h, "Content-Type")
			delete(h, "Content-Length")
			w.Header().Set("Last-Modified", modtime.UTC().Format(http.TimeFormat))
			w.WriteHeader(http.StatusNotModified)
			return
		}
	}
	
	mimeType := mime.TypeByExtension(filepath.Ext(static.Name))
	if mimeType != "" {
		w.Header().Set("Content-Type", mimeType)
	}
	w.Header().Set("Last-Modified", modtime.UTC().Format(http.TimeFormat))
	w.Write([]byte(static.Content))
}


var Files=StaticFiles{
   {{range $file := .files}}
      base64decode("{{$file.Name}}"):&StaticFile{
         Name:base64decode("{{$file.Name}}"),
         Mtime:{{$file.Mtime}},
         Content:decode("{{$file.Content}}"),
       },
	{{end}}
}

`))

type staticFile struct {
	Name       string
	NameOrigin string
	Mtime      int64
	Content    string
	Md5        string
}

var files []staticFile

func encode(data []byte) string {
	var buf bytes.Buffer
	gw := gzip.NewWriter(&buf)
	gw.Write(data)
	gw.Flush()
	gw.Close()
	return base64.StdEncoding.EncodeToString(buf.Bytes())
}

func walkerFor(basePath string) filepath.WalkFunc {
	//	baseName:=filepath.Base(basePath)

	return func(name string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.Mode().IsRegular() {
			nameRel, _ := filepath.Rel(basePath, name)
			if isIgnoreFile(nameRel) {
				return nil
			}
			data, ferr := ioutil.ReadFile(name)
			if ferr != nil {
				return ferr
			}
			//			nameSlash:=filepath.ToSlash(filepath.Clean(baseName+string(os.PathSeparator)+nameRel))
			nameSlash := filepath.ToSlash(nameRel)
			files = append(files, staticFile{
				Name:       base64.StdEncoding.EncodeToString([]byte(nameSlash)),
				NameOrigin: nameSlash,
				Content:    encode(data),
				Mtime:      info.ModTime().Unix(),
			})
		}

		return nil
	}
}
func isIgnoreFile(name string) bool {
	if name == outFileName {
		return true
	}
	subNames := strings.Split(name, "/")
	for _, n := range subNames {
		if n[:1] == "." {
			return true
		}
	}
	return false
}

func main() {
	flag.Usage = func() {
		fmt.Println("useage:")
		fmt.Println("\tgoassest", " [static dir path]")
		fmt.Println("\ntools for golang,merge all assest into go source code")
		fmt.Println("https://github.com/hidu/goassest/\n")
		flag.PrintDefaults()
	}
	flag.Parse()
	dirOrigin := flag.Arg(0)
	if dirOrigin == "" {
		flag.Usage()
		os.Exit(1)
	}
	dir, err := filepath.Abs(dirOrigin)
	if err != nil {
		fmt.Println("wrong dir")
		return
	}

	filepath.Walk(dir, walkerFor(dir))
	var buf bytes.Buffer
	datas := make(map[string]interface{})
	datas["files"] = files
	datas["package"] = filepath.Base(dir)

	tpl.Execute(&buf, datas)
	codeBytes, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Println("go code err", err)
		os.Exit(1)
	}

	outFilePath := dir + string(os.PathSeparator) + outFileName
	err = ioutil.WriteFile(outFilePath, codeBytes, 0655)
	if err == nil {
		fmt.Println("total ", len(files), "files")
		fmt.Println(strings.Repeat("-", 80))
		for _, staticFile := range files {
			fmt.Println("add", staticFile.NameOrigin)
		}
		fmt.Println(strings.Repeat("-", 80))
		fmt.Println("create ", filepath.Clean(dirOrigin+string(os.PathSeparator)+outFileName), "success")
	} else {
		fmt.Println("failed", err)
		os.Exit(2)
	}
}
