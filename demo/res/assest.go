// generated by goassest(0.5 20160518)
// https://github.com/hidu/goassest/

package res

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"flag"
	"fmt"
	"io/ioutil"
	"mime"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"strings"
	"time"
)

// AssestFile assest file  struct
type AssestFile struct {
	Name    string
	Mtime   int64
	Content string
}

// AssestStruct assest files
type AssestStruct struct {
	Files map[string]*AssestFile
}

var _assestDirect bool

func init() {
	exeName := filepath.Base(os.Getenv("_"))
	//only enable with go run
	if exeName == "go" || exeName == "go.exe" {
		flag.BoolVar(&_assestDirect, "assest_direct", false, "for debug,read assest direct")
	}
}

var _assestCwd, _ = os.Getwd()

// GetAssestFile get file by name
func (statics *AssestStruct) GetAssestFile(name string) (*AssestFile, error) {
	if name != "" && name[0] != '/' {
		name = "/" + name
	}
	name = path.Clean(name)
	if _assestDirect {
		f, err := os.Open(_assestCwd + string(filepath.Separator) + name)
		if err != nil {
			return nil, err
		}
		defer f.Close()
		info, err := f.Stat()
		if err != nil {
			return nil, err
		}
		if info.Mode().IsRegular() {
			content, err := ioutil.ReadAll(f)
			if err != nil {
				return nil, err
			}
			return &AssestFile{
				Content: string(content),
				Name:    name,
				Mtime:   info.ModTime().Unix(),
			}, nil
		}
		return nil, fmt.Errorf("not file")
	}
	if sf, has := statics.Files[name]; has {
		return sf, nil
	}
	return nil, fmt.Errorf("not exists")
}

// GetContent get content by name
func (statics AssestStruct) GetContent(name string) string {
	s, err := statics.GetAssestFile(name)
	if err != nil {
		return ""
	}
	return s.Content
}

// GetFileNames get all file names
func (statics AssestStruct) GetFileNames(dir string) []string {
	if dir == "" {
		dir = "/"
	}
	names := make([]string, len(statics.Files))
	dirRaw := dir
	dir = path.Clean(dir)

	if dir != "/" && strings.HasSuffix(dirRaw, "/") {
		dir += string(filepath.Separator)
	}

	dir = filepath.ToSlash(dir)

	for name := range statics.Files {
		if strings.HasPrefix(name, dir) {
			names = append(names, name)
		}
	}
	return names
}

// FileHandlerFunc handler http files
func (statics *AssestStruct) FileHandlerFunc(name string) http.HandlerFunc {
	if strings.Contains(name, "private") {
		return http.NotFound
	}
	static, err := statics.GetAssestFile(name)
	return func(w http.ResponseWriter, r *http.Request) {
		if err != nil {
			http.NotFound(w, r)
			return
		}
		modtime := time.Unix(static.Mtime, 0)
		modifiedSince := r.Header.Get("If-Modified-Since")
		if modifiedSince != "" {
			t, err := time.Parse(http.TimeFormat, modifiedSince)
			if err == nil && modtime.Before(t.Add(1*time.Second)) {
				w.Header().Del("Content-Type")
				w.Header().Del("Content-Length")
				w.Header().Set("Last-Modified", modtime.UTC().Format(http.TimeFormat))
				w.WriteHeader(http.StatusNotModified)
				return
			}
		}

		mimeType := mime.TypeByExtension(filepath.Ext(static.Name))
		if mimeType != "" {
			w.Header().Set("Content-Type", mimeType)
		}
		w.Header().Set("Last-Modified", modtime.UTC().Format(http.TimeFormat))
		w.Write([]byte(static.Content))
	}
}

// HTTPHandler handler http request
//eg:on file system is :/res/js/a.js and request is /res/js/a.js
//http.Handle("/res/",res.Assest.HttpHandler("/"))

//eg:on file system is :/res/js/a.js and request is /js/a.js
//http.Handle("/js/",res.Assest.HttpHandler("/res/"))
func (statics *AssestStruct) HTTPHandler(baseDir string) http.Handler {
	return &_assestFileServer{sf: statics, pdir: baseDir}
}

type _assestFileServer struct {
	sf   *AssestStruct
	pdir string
}

// ServeHTTP ServeHTTP
func (f *_assestFileServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	rname := filepath.Join(f.pdir, r.URL.Path)
	f.sf.FileHandlerFunc(rname).ServeHTTP(w, r)
}

func _assestGzipBase64decode(data string) string {
	b, _ := base64.StdEncoding.DecodeString(data)
	gr, _ := gzip.NewReader(bytes.NewBuffer(b))
	bs, _ := ioutil.ReadAll(gr)
	return string(bs)
}

func _assestBase64Decode(data string) string {
	b, _ := base64.StdEncoding.DecodeString(data)
	return string(b)
}

// Assest export assests
var Assest = &AssestStruct{
	Files: map[string]*AssestFile{

		_assestBase64Decode("L3Jlcy9iLmNzcw=="): &AssestFile{
			Name:    _assestBase64Decode("L3Jlcy9iLmNzcw=="),
			Mtime:   1440515205,
			Content: _assestGzipBase64decode("H4sIAAAJbogA/8owrE7LzyvRLc6sSrUysSiosE7Oz8kvskovSk3Nq80wroZwi1JTajNMkDgAAAAA//8BAAD///xF3Xc4AAAA"),
		},

		_assestBase64Decode("L3Jlcy9pbmRleC5odG1s"): &AssestFile{
			Name:    _assestBase64Decode("L3Jlcy9pbmRleC5odG1s"),
			Mtime:   1463833239,
			Content: _assestGzipBase64decode("H4sIAAAJbogA/5ySvVLDMBCE+zzFRb0j8lNQyG74aaEIBRUjy0dkR4k9uhsgb8/JDjMOpPBQaeZuv9tN1mZ+/3S3fX1+AM+HUMzMz4O2kueAbMF5Gwk5Vy/bx+xWyZhrDlh4DKEFS4TERg+zmQn1cQ8RQ66ITwHJI7ICPnWYK8Yv1o5IgY/4nisdkXS5SBMhycW647G0sR92mCqg6M5AQ9ouGkGMHpYT2SZ5XXLTQGLLtUu8+xefQo8oMPMsg83NBrJsYvTO7lCA8ZFfV/S5sbKtTimXX577+WxjqGS9lGVXGPv3rwe2cZf6fSuDPe5V0Y+NtuLWyS05tip27VA0VHho5dyqN1lDXeWqN0rZ/LroU6V6wLVHFm+ouU94qc7Ksb68or+Uu7HcXZPr4ZeLKn3B3wAAAP//AQAA///hx62x2AIAAA=="),
		},

		_assestBase64Decode("L3Jlcy9qcy9hLmpz"): &AssestFile{
			Name:    _assestBase64Decode("L3Jlcy9qcy9hLmpz"),
			Mtime:   1440515205,
			Content: _assestGzipBase64decode("H4sIAAAJbogA/ypOLQnJzE3NLy3RSCvNSy7JzM/T0KxOyU8uzU3NK9FLTy1xzUkFMZ0qPVM0lDJSc3LylTT1MvPyUos8Qnx9bCFCOol6WcUKRkrWtTqGBgYGmtYAAAAA//8BAAD//4rtx7JYAAAA"),
		},

		_assestBase64Decode("L3Jlcy9qcy9iLmpz"): &AssestFile{
			Name:    _assestBase64Decode("L3Jlcy9qcy9iLmpz"),
			Mtime:   1463832956,
			Content: _assestGzipBase64decode("H4sIAAAJbogA/ypOLQnJzE3NLy3RSCvNSy7JzM/T0KxOyU8uzU3NK9FLTy1xzUkFMZ0qPVM0lDJSc3LydZOUNPUy8/JSizxCfH1sIYI6SXpZxQpGSta1OoYGBgaa1gAAAAD//wEAAP//8g4AUloAAAA="),
		},

		_assestBase64Decode("L3Jlcy9qcy9jLmpz"): &AssestFile{
			Name:    _assestBase64Decode("L3Jlcy9qcy9jLmpz"),
			Mtime:   1463833139,
			Content: _assestGzipBase64decode("H4sIAAAJbogA/ypOLQnJzE3NLy3RSCvNSy7JzM/T0KxOyU8uzU3NK9FLTy1xzUkFMZ0qPVM0lDJSc3LydZOVNPUy8/JSizxCfH1sIYI6yXpZxQpGSta1OoYGBgaa1gAAAAD//wEAAP//fIiYfFoAAAA="),
		},
	},
}
